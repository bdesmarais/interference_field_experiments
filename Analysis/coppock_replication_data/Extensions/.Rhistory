pdf("Dummy_network_plot.pdf")
plot(net,vertex.color = cols, vertex.size = 15, vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
box(which = "figure", col = "black")
dev.off()
abc <- plot(net,vertex.color = cols, vertex.size = 15, vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
box(which = "figure", col = "black")
####
## Creating dummy network for poster
####
rm(list=ls())
library(igraph)
# Creating adjacency matrix
adj.mat <- matrix(0, 10, 10)
adj.mat[1,2] <- adj.mat[2,1] <- 1
adj.mat[2,3] <- adj.mat[3,2] <- 1
adj.mat[2,4] <- adj.mat[4,2] <- 1
adj.mat[3,4] <- adj.mat[4,3] <- 1
adj.mat[4,5] <- adj.mat[5,4] <- 1
adj.mat[4,6] <- adj.mat[6,4] <- 1
adj.mat[5,6] <- adj.mat[6,5] <- 1
adj.mat[5,8] <- adj.mat[8,5] <- 1
adj.mat[5,9] <- adj.mat[9,5] <- 1
adj.mat[6,7] <- adj.mat[7,6] <- 1
adj.mat[7,8] <- adj.mat[8,7] <- 1
adj.mat[9,10] <- adj.mat[10,9] <- 1
# Assigning treatment/control to nodes as an attribute
nodes <- as.data.frame(c("C","C","T","C","T","T","T","C","T","C"))
# Defining some reference vectors for plotting
vertcols <- c("dodgerblue4","white")
labcols <- c("white","dodgerblue4")
categories <- c("T", "C")
# Plotting
net <- graph.adjacency(adj.mat, mode = "undirected")
cols <- vertcols[match(as.character(nodes[,1]),categories)]
lcols <- labcols[match(as.character(nodes[,1]),categories)]
set.seed(5)
plot(net,vertex.color = cols, vertex.size = 15, vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
box(which = "figure", col = "black")
pdf("Dummy_network_plot.pdf")
plot(net,vertex.color = cols, vertex.size = 15, vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
box(which = "figure", col = "black")
dev.off()
####
## Creating dummy network for poster
####
rm(list=ls())
library(igraph)
# Creating adjacency matrix
adj.mat <- matrix(0, 10, 10)
adj.mat[1,2] <- adj.mat[2,1] <- 1
adj.mat[2,3] <- adj.mat[3,2] <- 1
adj.mat[2,4] <- adj.mat[4,2] <- 1
adj.mat[3,4] <- adj.mat[4,3] <- 1
adj.mat[4,5] <- adj.mat[5,4] <- 1
adj.mat[4,6] <- adj.mat[6,4] <- 1
adj.mat[5,6] <- adj.mat[6,5] <- 1
adj.mat[5,8] <- adj.mat[8,5] <- 1
adj.mat[5,9] <- adj.mat[9,5] <- 1
adj.mat[6,7] <- adj.mat[7,6] <- 1
adj.mat[7,8] <- adj.mat[8,7] <- 1
adj.mat[9,10] <- adj.mat[10,9] <- 1
# Assigning treatment/control to nodes as an attribute
nodes <- as.data.frame(c("C","C","T","C","T","T","T","C","T","C"))
# Defining some reference vectors for plotting
vertcols <- c("dodgerblue4","white")
labcols <- c("white","dodgerblue4")
categories <- c("T", "C")
# Plotting
net <- graph.adjacency(adj.mat, mode = "undirected")
cols <- vertcols[match(as.character(nodes[,1]),categories)]
lcols <- labcols[match(as.character(nodes[,1]),categories)]
set.seed(5)
plot(net,vertex.color = cols, vertex.size = 15,
vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
box(which = "figure", col = "black")
pdf("Dummy_network_plot.pdf")
plot(net,vertex.color = cols, vertex.size = 15, vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
box(which = "figure", col = "black")
dev.off()
plot(net,vertex.color = cols, vertex.size = 15,
####
## Creating dummy network for poster
####
rm(list=ls())
library(igraph)
# Creating adjacency matrix
adj.mat <- matrix(0, 10, 10)
adj.mat[1,2] <- adj.mat[2,1] <- 1
adj.mat[2,3] <- adj.mat[3,2] <- 1
adj.mat[2,4] <- adj.mat[4,2] <- 1
adj.mat[3,4] <- adj.mat[4,3] <- 1
adj.mat[4,5] <- adj.mat[5,4] <- 1
adj.mat[4,6] <- adj.mat[6,4] <- 1
adj.mat[5,6] <- adj.mat[6,5] <- 1
adj.mat[5,8] <- adj.mat[8,5] <- 1
adj.mat[5,9] <- adj.mat[9,5] <- 1
adj.mat[6,7] <- adj.mat[7,6] <- 1
adj.mat[7,8] <- adj.mat[8,7] <- 1
adj.mat[9,10] <- adj.mat[10,9] <- 1
# Assigning treatment/control to nodes as an attribute
nodes <- as.data.frame(c("C","C","T","C","T","T","T","C","T","C"))
# Defining some reference vectors for plotting
vertcols <- c("dodgerblue4","white")
labcols <- c("white","dodgerblue4")
categories <- c("T", "C")
# Plotting
net <- graph.adjacency(adj.mat, mode = "undirected")
cols <- vertcols[match(as.character(nodes[,1]),categories)]
lcols <- labcols[match(as.character(nodes[,1]),categories)]
set.seed(5)
plot(net,vertex.color = cols, vertex.size = 15,
vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
box(which = "figure", col = "black")
pdf("Dummy_network_plot.pdf")
plot(net,vertex.color = cols, vertex.size = 15, vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
box(which = "figure", col = "black")
dev.off()
plot(net,vertex.color = cols, vertex.size = 15,
vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
box(which = "figure", col = "black")
####
## Creating dummy network for poster
####
rm(list=ls())
library(igraph)
# Creating adjacency matrix
adj.mat <- matrix(0, 10, 10)
adj.mat[1,2] <- adj.mat[2,1] <- 1
adj.mat[2,3] <- adj.mat[3,2] <- 1
adj.mat[2,4] <- adj.mat[4,2] <- 1
adj.mat[3,4] <- adj.mat[4,3] <- 1
adj.mat[4,5] <- adj.mat[5,4] <- 1
adj.mat[4,6] <- adj.mat[6,4] <- 1
adj.mat[5,6] <- adj.mat[6,5] <- 1
adj.mat[5,8] <- adj.mat[8,5] <- 1
adj.mat[5,9] <- adj.mat[9,5] <- 1
adj.mat[6,7] <- adj.mat[7,6] <- 1
adj.mat[7,8] <- adj.mat[8,7] <- 1
adj.mat[9,10] <- adj.mat[10,9] <- 1
# Assigning treatment/control to nodes as an attribute
nodes <- as.data.frame(c("C","C","T","C","T","T","T","C","T","C"))
vertcols <- c("dodgerblue4","white")
labcols <- c("white","dodgerblue4")
categories <- c("T", "C")
# Plotting
net <- graph.adjacency(adj.mat, mode = "undirected")
cols <- vertcols[match(as.character(nodes[,1]),categories)]
lcols <- labcols[match(as.character(nodes[,1]),categories)]
set.seed(5)
plot(net, vertex.color = cols, vertex.size = 15,
vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold)
set.seed(1)
#Simulate the asymmetric issue
asymmetry.sim <- function (num.nodes=400, #number of nominators
scale=3,
offset=0,
y.noise=0.02, #standard deviation
friend.noms=1, #number of nominees for each nominator
response="linear",
nominate.by="distance",
time.trend=0.3) {
?array
#Ã‘reate covariates
invlogit <- function(cc) exp(cc)/(1+exp(cc))
xx <- runif(num.nodes) #scalar latent attribute
distances <- as.matrix(dist(xx, diag=TRUE, upper=TRUE)) #distance matrix
#potential friends - underlying undirected network:
#edges are more likely to form between individuals with similar values of X
adj.probs <- array(rbinom(length(distances), 1, invlogit(offset-scale*distances)), dim(distances))
diag(adj.probs) <- 0
adj.probs[lower.tri(adj.probs)] <- t(adj.probs)[lower.tri(adj.probs)]
fixed.x.dist <- distances
diag(fixed.x.dist) <- Inf
#Each individual nominates one friend:
nominees <- t(rbind(sapply(1:num.nodes, FUN=function(ii) {
possibles <- which(adj.probs[ii,] == 1)
return(ifelse(rep(nominate.by=="distance",friend.noms),
possibles[which(order(fixed.x.dist[ii,possibles])<=friend.noms)],
sample(possibles, size=friend.noms, prob=invlogit(-abs((xx[possibles] - 0.5))))
))
})))
#true adjacency matrix.
aa.mat <- array(0, dim(distances))
for (ii in 1:num.nodes) aa.mat[ii, nominees[ii,]] <- 1
#backwards matrix.
rev.aa.mat <- t(aa.mat)
#establishing time trends of the observable outcomes:
y1 = (xx-0.5)^3+rnorm(num.nodes,0,y.noise) # t = 0
y2 = y1+rnorm(num.nodes,time.trend*xx,y.noise) # t = 1
infl.y1 <- aa.mat%*%y1 #outcome for true adjancency matrix
back.y1 <- rev.aa.mat%*%y1 #outcome for backwards matrix
# linear model
XX <- cbind(1, y1, infl.y1, back.y1)
trial <- lm(y2 ~ y1 + infl.y1 + back.y1)
#store coefficients
coef.table <- summary(trial)$coefficients[,1]
v.plus.c <- c(diag(summary(trial)$cov.unscaled), summary(trial)$cov.unscaled[3,4])*summary(trial)$sigma^2
#Calculate z-statistics (the difference between the "sender" and "receiver" coefficients)
z.stat <- (coef.table[3]-coef.table[4])/sqrt(v.plus.c[3]+v.plus.c[4]+2*v.plus.c[5])
#Outcome
out <- cbind(c(coef.table, v.plus.c, z.stat))
rownames(out) <- c("int.b", #intercept at t=1
"auto.b", #autocorrelation at t=1
"infl.b", #the effect of the nominee's status at time t=1 on the nominator
"back.b", #converse, the network effect if i was nominated by j, at t=1
"int.s", #intercept at t=0
"auto.s",#autocorrelation at t=0
"infl.s", ##the effect of the nominee's status at time t=0 on the nominator
"back.s", #converse, the network effect if i was nominated by j, at t=0
"cov.infl.back", #covariance between "sender" and "receiver" effects
"z.stat" #z-score
)
return(out)
}
result <- replicate(500, asymmetry.sim(friend=1, time.trend=0.3))
###Asymmetric model presented by C.R.Shalizi and A.C.Thomas (2010)
###Method Presentation. Zhanna Terechshenko
###This is a toy model of a network with latent homophily on an X variable that controls
###an observable time series Y at multiple points, but with no direct influence
###between values of Y for different nodes. This model shows that despite the lack
###of direct interaction, it is possible to predict Y(t) from Y(t-1),
###and these relations are asymmetric across unreciprocated edges.
#Set seed
set.seed(1)
#Simulate the asymmetric issue
asymmetry.sim <- function (num.nodes=400, #number of nominators
scale=3,
offset=0,
y.noise=0.02, #standard deviation
friend.noms=1, #number of nominees for each nominator
response="linear",
nominate.by="distance",
time.trend=0.3) {
#Ã‘reate covariates
invlogit <- function(cc) exp(cc)/(1+exp(cc))
xx <- runif(num.nodes) #scalar latent attribute
distances <- as.matrix(dist(xx, diag=TRUE, upper=TRUE)) #distance matrix
#potential friends - underlying undirected network:
#edges are more likely to form between individuals with similar values of X
adj.probs <- array(rbinom(length(distances), 1, invlogit(offset-scale*distances)), dim(distances))
diag(adj.probs) <- 0
adj.probs[lower.tri(adj.probs)] <- t(adj.probs)[lower.tri(adj.probs)]
fixed.x.dist <- distances
diag(fixed.x.dist) <- Inf
#Each individual nominates one friend:
nominees <- t(rbind(sapply(1:num.nodes, FUN=function(ii) {
possibles <- which(adj.probs[ii,] == 1)
return(ifelse(rep(nominate.by=="distance",friend.noms),
possibles[which(order(fixed.x.dist[ii,possibles])<=friend.noms)],
sample(possibles, size=friend.noms, prob=invlogit(-abs((xx[possibles] - 0.5))))
))
})))
#true adjacency matrix.
aa.mat <- array(0, dim(distances))
for (ii in 1:num.nodes) aa.mat[ii, nominees[ii,]] <- 1
#backwards matrix.
rev.aa.mat <- t(aa.mat)
#establishing time trends of the observable outcomes:
y1 = (xx-0.5)^3+rnorm(num.nodes,0,y.noise) # t = 0
y2 = y1+rnorm(num.nodes,time.trend*xx,y.noise) # t = 1
infl.y1 <- aa.mat%*%y1 #outcome for true adjancency matrix
back.y1 <- rev.aa.mat%*%y1 #outcome for backwards matrix
# linear model
XX <- cbind(1, y1, infl.y1, back.y1)
trial <- lm(y2 ~ y1 + infl.y1 + back.y1)
#store coefficients
coef.table <- summary(trial)$coefficients[,1]
v.plus.c <- c(diag(summary(trial)$cov.unscaled), summary(trial)$cov.unscaled[3,4])*summary(trial)$sigma^2
#Calculate z-statistics (the difference between the "sender" and "receiver" coefficients)
z.stat <- (coef.table[3]-coef.table[4])/sqrt(v.plus.c[3]+v.plus.c[4]+2*v.plus.c[5])
#Outcome
out <- cbind(c(coef.table, v.plus.c, z.stat))
rownames(out) <- c("int.b", #intercept at t=1
"auto.b", #autocorrelation at t=1
"infl.b", #the effect of the nominee's status at time t=1 on the nominator
"back.b", #converse, the network effect if i was nominated by j, at t=1
"int.s", #intercept at t=0
"auto.s",#autocorrelation at t=0
"infl.s", ##the effect of the nominee's status at time t=0 on the nominator
"back.s", #converse, the network effect if i was nominated by j, at t=0
"cov.infl.back", #covariance between "sender" and "receiver" effects
"z.stat" #z-score
)
return(out)
}
#Simulation
result <- replicate(500, asymmetry.sim(friend=1, time.trend=0.3))
rm(list=ls())
###Asymmetric model presented by C.R.Shalizi and A.C.Thomas (2010)
###Method Presentation. Zhanna Terechshenko
###This is a toy model of a network with latent homophily on an X variable that controls
###an observable time series Y at multiple points, but with no direct influence
###between values of Y for different nodes. This model shows that despite the lack
###of direct interaction, it is possible to predict Y(t) from Y(t-1),
###and these relations are asymmetric across unreciprocated edges.
#Set seed
set.seed(1)
#Simulate the asymmetric issue
asymmetry.sim <- function (num.nodes=400, #number of nominators
scale=3,
offset=0,
y.noise=0.02, #standard deviation
friend.noms=1, #number of nominees for each nominator
response="linear",
nominate.by="distance",
time.trend=0.3) {
#Ã‘reate covariates
invlogit <- function(cc) exp(cc)/(1+exp(cc))
xx <- runif(num.nodes) #scalar latent attribute
distances <- as.matrix(dist(xx, diag=TRUE, upper=TRUE)) #distance matrix
#potential friends - underlying undirected network:
#edges are more likely to form between individuals with similar values of X
adj.probs <- array(rbinom(length(distances), 1, invlogit(offset-scale*distances)), dim(distances))
diag(adj.probs) <- 0
adj.probs[lower.tri(adj.probs)] <- t(adj.probs)[lower.tri(adj.probs)]
fixed.x.dist <- distances
diag(fixed.x.dist) <- Inf
#Each individual nominates one friend:
nominees <- t(rbind(sapply(1:num.nodes, FUN=function(ii) {
possibles <- which(adj.probs[ii,] == 1)
return(ifelse(rep(nominate.by=="distance",friend.noms),
possibles[which(order(fixed.x.dist[ii,possibles])<=friend.noms)],
sample(possibles, size=friend.noms, prob=invlogit(-abs((xx[possibles] - 0.5))))
))
})))
#true adjacency matrix.
aa.mat <- array(0, dim(distances))
for (ii in 1:num.nodes) aa.mat[ii, nominees[ii,]] <- 1
#backwards matrix.
rev.aa.mat <- t(aa.mat)
#establishing time trends of the observable outcomes:
y1 = (xx-0.5)^3+rnorm(num.nodes,0,y.noise) # t = 0
y2 = y1+rnorm(num.nodes,time.trend*xx,y.noise) # t = 1
infl.y1 <- aa.mat%*%y1 #outcome for true adjancency matrix
back.y1 <- rev.aa.mat%*%y1 #outcome for backwards matrix
# linear model
XX <- cbind(1, y1, infl.y1, back.y1)
trial <- lm(y2 ~ y1 + infl.y1 + back.y1)
#store coefficients
coef.table <- summary(trial)$coefficients[,1]
v.plus.c <- c(diag(summary(trial)$cov.unscaled), summary(trial)$cov.unscaled[3,4])*summary(trial)$sigma^2
#Calculate z-statistics (the difference between the "sender" and "receiver" coefficients)
z.stat <- (coef.table[3]-coef.table[4])/sqrt(v.plus.c[3]+v.plus.c[4]+2*v.plus.c[5])
#Outcome
out <- cbind(c(coef.table, v.plus.c, z.stat))
rownames(out) <- c("int.b", #intercept at t=1
"auto.b", #autocorrelation at t=1
"infl.b", #the effect of the nominee's status at time t=1 on the nominator
"back.b", #converse, the network effect if i was nominated by j, at t=1
"int.s", #intercept at t=0
"auto.s",#autocorrelation at t=0
"infl.s", ##the effect of the nominee's status at time t=0 on the nominator
"back.s", #converse, the network effect if i was nominated by j, at t=0
"cov.infl.back", #covariance between "sender" and "receiver" effects
"z.stat" #z-score
)
return(out)
}
#Simulation
result <- replicate(50, asymmetry.sim(friend=1, time.trend=0.3))
dim(result)
#plot the results of the simulations
par(mfrow=c(1,2))
hist(result[3,,], main="Effect of Phantom `Influencer' on `Influenced' in Time Series", xlab="Regression Coefficient"); hist(result[10,,], main="z-score of Directional Difference", xlab=paste("Proportion greater than 0:", mean(result[10,,]>0)))
###Asymmetric model presented by C.R.Shalizi and A.C.Thomas (2010)
###Method Presentation. Zhanna Terechshenko
###This is a toy model of a network with latent homophily on an X variable that controls
###an observable time series Y at multiple points, but with no direct influence
###between values of Y for different nodes. This model shows that despite the lack
###of direct interaction, it is possible to predict Y(t) from Y(t-1),
###and these relations are asymmetric across unreciprocated edges.
#Set seed
set.seed(1)
#Simulate the asymmetric issue
asymmetry.sim <- function (num.nodes=400, #number of nominators
scale=3,
offset=0,
y.noise=0.02, #standard deviation
friend.noms=1, #number of nominees for each nominator
response="linear",
nominate.by="distance",
time.trend=0.3) {
#Ã‘reate covariates
invlogit <- function(cc) exp(cc)/(1+exp(cc))
xx <- runif(num.nodes) #scalar latent attribute
distances <- as.matrix(dist(xx, diag=TRUE, upper=TRUE)) #distance matrix
#potential friends - underlying undirected network:
#edges are more likely to form between individuals with similar values of X
adj.probs <- array(rbinom(length(distances), 1, invlogit(offset-scale*distances)), dim(distances))
diag(adj.probs) <- 0
adj.probs[lower.tri(adj.probs)] <- t(adj.probs)[lower.tri(adj.probs)]
fixed.x.dist <- distances
diag(fixed.x.dist) <- Inf
#Each individual nominates one friend:
nominees <- t(rbind(sapply(1:num.nodes, FUN=function(ii) {
possibles <- which(adj.probs[ii,] == 1)
return(ifelse(rep(nominate.by=="distance",friend.noms),
possibles[which(order(fixed.x.dist[ii,possibles])<=friend.noms)],
sample(possibles, size=friend.noms, prob=invlogit(-abs((xx[possibles] - 0.5))))
))
})))
#true adjacency matrix.
aa.mat <- array(0, dim(distances))
for (ii in 1:num.nodes) aa.mat[ii, nominees[ii,]] <- 1
#backwards matrix.
rev.aa.mat <- t(aa.mat)
#establishing time trends of the observable outcomes:
y1 = (xx-0.5)^3+rnorm(num.nodes,0,y.noise) # t = 0
y2 = y1+rnorm(num.nodes,time.trend*xx,y.noise) # t = 1
infl.y1 <- aa.mat%*%y1 #outcome for true adjancency matrix
back.y1 <- rev.aa.mat%*%y1 #outcome for backwards matrix
# linear model
XX <- cbind(1, y1, infl.y1, back.y1)
trial <- lm(y2 ~ y1 + infl.y1 + back.y1)
#store coefficients
coef.table <- summary(trial)$coefficients[,1]
v.plus.c <- c(diag(summary(trial)$cov.unscaled), summary(trial)$cov.unscaled[3,4])*summary(trial)$sigma^2
#Calculate z-statistics (the difference between the "sender" and "receiver" coefficients)
z.stat <- (coef.table[3]-coef.table[4])/sqrt(v.plus.c[3]+v.plus.c[4]+2*v.plus.c[5])
#Outcome
out <- cbind(c(coef.table, v.plus.c, z.stat))
rownames(out) <- c("int.b", #intercept at t=1
"auto.b", #autocorrelation at t=1
"infl.b", #the effect of the nominee's status at time t=1 on the nominator
"back.b", #converse, the network effect if i was nominated by j, at t=1
"int.s", #intercept at t=0
"auto.s",#autocorrelation at t=0
"infl.s", ##the effect of the nominee's status at time t=0 on the nominator
"back.s", #converse, the network effect if i was nominated by j, at t=0
"cov.infl.back", #covariance between "sender" and "receiver" effects
"z.stat" #z-score
)
return(out)
}
#Simulation
result <- replicate(500, asymmetry.sim(friend=1, time.trend=0.3))
dim(result)
#plot the results of the simulations
par(mfrow=c(1,2))
hist(result[3,,], main="Effect of Phantom `Influencer' on `Influenced' in Time Series", xlab="Regression Coefficient"); hist(result[10,,], main="z-score of Directional Difference", xlab=paste("Proportion greater than 0:", mean(result[10,,]>0)))
setwd("D:/Dropbox/Interference_in_Field_Experiments/Analysis/coppock_replication_data/Extensions")
abc <- read.table("pvals_coppock_ideo_12nn.csv",header = TRUE, sep = '', na.strings = ".")
pvals <- matrix(NA, 41, 41)
for(i in 1:41){pvals[i,] <- as.numeric(abc[i,])}
beta1s <- seq(from=-0.5, to=0.5, by=0.025)
beta2s <- seq(from=-0.5, to=0.5, by=0.025)
library(fields)
pdf("pval_plot_coppock_ideo_12nn.pdf")
image.plot(beta1s, beta2s, pvals,
main = "Plot of p-values: k=12",
xlab = "Direct effects", ylab = "Indirect effects")
# Lines for point estimate
lines(beta1s, rep(indirect.effect.PI, nrow(pvals)),
type = "l", col = "yellow", lty = 1) #indirect
highest.p.indices <- which(pvals==max(pvals), arr.ind = TRUE)
direct.effect.PI <- beta1s[which(pvals==max(pvals), arr.ind = TRUE)[1]]
indirect.effect.PI <- beta2s[which(pvals==max(pvals), arr.ind = TRUE)[2]]
direct.effect.CI.high <- beta1s[max(which(pvals[,which(beta2s==indirect.effect.PI)] >= 0.05))]
direct.effect.CI.low <- beta1s[min(which(pvals[,which(beta2s==indirect.effect.PI)] >= 0.05))]
indirect.effect.CI.high <- beta2s[max(which(pvals[which(beta1s==direct.effect.PI),] >= 0.05))]
indirect.effect.CI.low <- beta2s[min(which(pvals[which(beta1s==direct.effect.PI),] >= 0.05))]
dev.off()
dev.off()
pdf("pval_plot_coppock_ideo_12nn.pdf")
image.plot(beta1s, beta2s, pvals,
main = "Plot of p-values: k=12",
xlab = "Direct effects", ylab = "Indirect effects")
# Lines for point estimate
lines(beta1s, rep(indirect.effect.PI, nrow(pvals)),
type = "l", col = "yellow", lty = 1) #indirect
lines(rep(direct.effect.PI, nrow(pvals)), beta2s,
type = "l", col = "yellow", lty = 1) #direct
# Lines for 95% CI
lines(beta1s, rep(indirect.effect.CI.low, nrow(pvals)),
type = "l", col = "yellow", lty = 2) #indirect low
lines(beta1s, rep(indirect.effect.CI.high, nrow(pvals)),
type = "l", col = "yellow", lty = 2) #indirect high
lines(rep(direct.effect.CI.high, nrow(pvals)), beta2s,
type = "l", col = "yellow", lty = 2) #direct high
lines(rep(direct.effect.CI.low, nrow(pvals)), beta2s,
type = "l", col = "yellow", lty = 2) #direct low
dev.off()
