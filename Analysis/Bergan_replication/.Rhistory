S[,,iter,t] <- S[,,r,t]
for (j in 1:n) {
for (i in 1:n) {
prob <- inv.logit(something(j = j, i = i, r = r, t = t, Y = Y, W = W, params = pars[t,]))
value <- sample(c(0,1), size = 1, prob = c(prob, 1-prob))
S[j,i,r,t] <- value
}
}
}
## Calculating averages
for(i in 1:n){
for(j in 1:n){
Sji_avg[i,j,t] <- mean(S[i,j,,t])
}
}
####
#### M-step
####
optimized <- optim(rep(0.1, 8), fn = log_lik, S = Sji_avg[,,t], Y = Y, W = W, N = N, method = "L-BFGS-B", control = list(fnscale = -1), lower = rep(-10, 8), upper = rep(10, 8))
#Updating the trackers
pars[t+1, ] <- optimized$par
likelihood[t+1] <- log_lik(params = optimized$par, S = Sji_avg[,,t], Y = Y, N = N, W = W)
}
et <- Sys.time()
et - st
#S
likelihood
pars
###############################################
#### Simulating the preliminary procedure ####
##############################################
## This code simulates the initial proposal.
## It includes the EM algorithm, using ERGM and lm.
## These results will be used in the comps paper.
# Author: Sayali Phadke
# Created on: 04/12/2017
# Last edited on: 11/04/2017
# Last edited by: Sayali
rm(list=ls())
gc()
set.seed(312)
####
#### Loading required packages
####
library(abind) #working with arrays
library(boot) #don't remember
library(gtools) #for permutations
library(network) #working with networks
####
#### Setup
####
n <- 5 #number of nodes
## Binary treatment assignment (W)
W <- sample(x = 0:1, size = n, replace = TRUE, prob = c(0.5, 0.5))
## Undirected network (N) as an adjacency matrix
N.edges <- sample(0:1, size= 2*n, replace = TRUE)
N <- matrix(NA, n, n, byrow = TRUE)
N[upper.tri(N)] <- N.edges
N[lower.tri(N)] <- t(N)[lower.tri(N)]
diag(N) <- 0
rm(N.edges)
## Spillover (S) as an adjacency matrix
## Designed so that for each pair of nodes that are connected,
# if they are both treated, spillover with probability p_tt,
# if both control, spillover with probability p_cc
# if sender treated, receiver control, spillover with probability p_tc
# if sender control, receiver treated, spillover with probability p_ct
# p_tc > p_tt > p_cc > p_ct
# Those not connected in N have zero spillover
initial_S <- matrix(NA, n, n)
spill_probs <- c(0.8, 0.6, 0.12, 0.05)
names(spill_probs) <- c("p_tc", "p_tt", "p_cc", "p_ct")
for (i in 1:n){
for (j in 1:n){
if (N[i,j] == 1){
if(W[i] == 1 && W[j] == 0){
p <- spill_probs["p_tc"]
initial_S[i,j] <- sample(0:1, size = 1, prob = c(p, 1-p))
} else if(W[i] == 1 && W[j] == 1){
p <- spill_probs["p_tt"]
initial_S[i,j] <- sample(0:1, size = 1, prob = c(p, 1-p))
} else if(W[i] == 0 && W[j] == 0){
p <- spill_probs["p_cc"]
initial_S[i,j] <- sample(0:1, size = 1, prob = c(p, 1-p))
} else { #This should be the condition where sender is control and receiver treated
p <- spill_probs["p_ct"]
initial_S[i,j] <- sample(0:1, size = 1, prob = c(p, 1-p))
}
} else {
initial_S[i,j] <- 0 #Sij=0 if Nij=0
}
}
}
# diag(S) <- 0 #Redundant since Sij=0 if Nij=0
## Visualizing the observed network
# network <- network(N)
# plot(network)
## Continuous outcome
## This depends upon treatment W and spillover S
# Currently takes the following form:
# Yi = 0.5 + 0.2*Wi + 1.65*sum(Sji) + 0.35*Wi*sum(Sji)
Y <- 0.5 + (0.2*W) + (1.65*apply(initial_S, MARGIN = 2, FUN = sum)) + (0.35*W*apply(initial_S, MARGIN = 2, FUN = sum))
####
## Question: Should i add an error to the outcome vector?
####
####
#### Required functions
####
## In this section, we create various functions
# As a first step, we create important components
# Each of them is setup for a given i, j
## Term 1: coefficient corresponding to double sum of Sij
T1 <- function(Y, W, params){
term1 <- params[ind["theta_zero"]] + params[ind["theta_one"]]*W[i]*W[j] +
params[ind["theta_two"]]*(1-W[i])*(1-W[j]) + params[ind["theta_three"]]*W[i]*(1-W[j]) -
((params[ind["beta_zero"]]*params[ind["beta_two"]] + params[ind["beta_one"]]*params[ind["beta_two"]]*W[i] +
params[ind["beta_zero"]]*params[ind["beta_three"]]*W[i] + params[ind["beta_one"]]*params[ind["beta_three"]]*W[i] -
params[ind["beta_two"]]*Y[i] + params[ind["beta_three"]]*W[i]*Y[i]) / sigma^2)
return(term1)
}
## Term 2: coefficient corresponding to sum_i(squared sum_j of S.ji)
##
## Note: this term has a multiplier (sum_k S.ki) when included in "something"
## "something" is the logit of bernoulli probability used to draw S.ji
## i.e. S.ji ~ bernoulli(p) where p = logit^-1 (something)
##
T2 <- function(W, params){
term2 <- ((-1)*(params[ind["beta_two"]]^2 + params[ind["beta_three"]]^2*W[i]^2 +
2*params[ind["beta_two"]]*params[ind["beta_three"]]*W[i])) / (2*sigma^2)
return(term2)
}
## Function to calculate MCMC draw probabilities
something <- function(j, i, r, t, Y, W, params){
#S: the matrix to use as a reference
# r is the value of current MCMC iteration
# we want to re-evaluate the probability for every i,j
# when i = j = 1, it technically takes S from the previous iteration
# for others, we use S from the same iteration
something <- T1(Y, W, params) + ((sum(S[,i,r,t])) - S[i,i,r,t] + 1)*T2(W, params) ##Multiplier for T2 needs to be checked!
return(something)
}
## Function to evaluate the log likelihood
# Written as A+B on page 24 of notes
squared_term <- function(x){
#input is the ith column of the spillover matrix of interest
t2_mult <- 0
sets <- permutations(n = length(x), r = 2, repeats.allowed = TRUE)
for(i in 1:nrow(sets)){
t2_mult <- t2_mult + prod(x[c(sets[i,])])
}
return(t2_mult)
}
log_lik <- function(params, S, Y, N, W){
r <- dim(S)[3] #Evaluate likelihood using the latest S
#Input is the matrix; must specify r and t
l <- 0
# Iteratively add to the value of log likelihood
######## ASSUMPTION: we are adding the squared term twice
for (i in 1:n){
for (j in 1:n){
value <- S[j,i]*(T1(Y, W, params)) +
(squared_term(S[,i]))*T2(W, params)
}
l <- l + value
}
return(l)
}
####
## Question: Should there be separate S.ij and S.ji?
####
####
## Setup for the EM to kickoff
####
## Initial parameters
initial_pars <- runif(8, 0, 10)
#initial_pars <- c(seq(0, 1, length.out = 4), seq(0, 1, length.out = 4))
ind <- 1:length(initial_pars)
names(ind) <- c("beta_zero", "beta_one", "beta_two", "beta_three", "theta_zero", "theta_one", "theta_two", "theta_three")
sigma <- rnorm(n = 1, mean = 3.5, sd = 0.27)
## Iterations
rep_mcmc <- 5 #number of MCMC iterations: looped over r
rep_em <- 10 #number of EM iterations: looped over t
## Turning into an array
# We would like to make S a 3D array,
# third D will track the MCMC iteration the code is at
S <- array(data = NA, dim = c(n, n, rep_mcmc+1, rep_em))
S[,,1,1] <- initial_S
## Trcking parameters
pars <- matrix(NA, rep_em+1, length(initial_pars))
pars[1,] <- initial_pars
## Arrays to track the sample averages
Sji_avg <- array(data = NA, dim = c(n,n,rep_em))
Sji_Ski_prod_avg <- array(data = NA, dim = c(n,n,rep_em)) ##Currently not tracking it, since we are assuming edge independence
# Even if we did want to separately track it, we can recycle the squared term function
## Tracking the likelihood
likelihood <- rep(NA, rep_em+1)
likelihood[1] <- log_lik(params = initial_pars, S = S[,,1,1], Y = Y, N = N, W = W) #initial likelihood
st <- Sys.time()
####
#### E-step
####
for (t in 1:rep_em){
if(t > 1){
S[,,1,t] <- S[,,dim(S)[3],t-1]
}
for (r in 1:rep_mcmc) {
iter <- r + 1
S[,,iter,t] <- S[,,r,t]
for (j in 1:n) {
for (i in 1:n) {
prob <- inv.logit(something(j = j, i = i, r = r, t = t, Y = Y, W = W, params = pars[t,]))
value <- sample(c(0,1), size = 1, prob = c(prob, 1-prob))
S[j,i,r,t] <- value
}
}
}
## Calculating averages
for(i in 1:n){
for(j in 1:n){
Sji_avg[i,j,t] <- mean(S[i,j,,t])
}
}
####
#### M-step
####
optimized <- optim(rep(0.1, 8), fn = log_lik, S = Sji_avg[,,t], Y = Y, W = W, N = N, method = "L-BFGS-B", control = list(fnscale = -1), lower = rep(-20, 8), upper = rep(20, 8))
#Updating the trackers
pars[t+1, ] <- optimized$par
likelihood[t+1] <- log_lik(params = optimized$par, S = Sji_avg[,,t], Y = Y, N = N, W = W)
}
et <- Sys.time()
et - st
#S
likelihood
pars
#
## Setup
#
rm(list=ls())
gc()
set.seed(12345)
library(igraph)
#
## Common adjacency matrix
#
# Creating adjacency matrix
adj.mat <- matrix(0, 10, 10)
adj.mat[1,2] <- adj.mat[2,1] <- 1
adj.mat[2,3] <- adj.mat[3,2] <- 1
adj.mat[2,4] <- adj.mat[4,2] <- 1
adj.mat[3,4] <- adj.mat[4,3] <- 1
adj.mat[4,5] <- adj.mat[5,4] <- 1
adj.mat[4,6] <- adj.mat[6,4] <- 1
adj.mat[5,6] <- adj.mat[6,5] <- 1
adj.mat[5,8] <- adj.mat[8,5] <- 1
adj.mat[5,9] <- adj.mat[9,5] <- 1
adj.mat[6,7] <- adj.mat[7,6] <- 1
adj.mat[7,8] <- adj.mat[8,7] <- 1
adj.mat[9,10] <- adj.mat[10,9] <- 1
#
## Plot 1: all control
#
# Assigning treatment/control to nodes as an attribute
nodes <- as.data.frame(c("C","C","C","C","C","C","C","C","C","C"))
# Defining some reference vectors for plotting
vertcols <- c("#56B4E9")
labcols <- c("black")
categories <- c("C")
vertsizes <- rep(20, nrow(adj.mat))
# Plotting
net <- graph.adjacency(adj.mat, mode = "undirected")
cols <- vertcols[match(as.character(nodes[,1]),categories)]
lcols <- labcols[match(as.character(nodes[,1]),categories)]
set.seed(5)
plot(net, vertex.color = cols, vertex.size = vertsizes,
vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold,
main = "All control: Uniform fraudulent registration")
box(which = "plot", col = "black")
#
## Plot 2: randomly treated
#
# Assigning treatment/control to nodes as an attribute
nodes <- as.data.frame(c("C","T","C","C","C","T","C","C","T","T"))
# Defining some reference vectors for plotting
vertcols <- c("#56B4E9", "#E69F00")
labcols <- c("black", "black")
categories <- c("T", "C")
vertsizes <- rep(20, nrow(adj.mat))
vertsizes[nodes == "T"] <- 10
# Plotting
net <- graph.adjacency(adj.mat, mode = "undirected")
cols <- vertcols[match(as.character(nodes[,1]),categories)]
lcols <- labcols[match(as.character(nodes[,1]),categories)]
set.seed(5)
plot(net, vertex.color = cols, vertex.size = vertsizes,
vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold,
main = "Randomized treatment: Fraudulent registration at control centers")
box(which = "plot", col = "black")
#
## Plot 2: Spilled over treatment
#
# Assigning treatment/control to nodes as an attribute
nodes <- as.data.frame(c("C","T","C","C","C","T","C","C","T","T"))
# Defining some reference vectors for plotting
vertcols <- c("#56B4E9", "#E69F00")
labcols <- c("black", "black")
#
## Plot 2: randomly treated
#
# Assigning treatment/control to nodes as an attribute
nodes <- as.data.frame(c("C","T","C","C","C","T","C","C","T","T"))
# Defining some reference vectors for plotting
vertcols <- c("#56B4E9", "#E69F00")
labcols <- c("black", "black")
categories <- c("T", "C")
vertsizes <- rep(20, nrow(adj.mat))
vertsizes[nodes == "T"] <- 15
# Plotting
net <- graph.adjacency(adj.mat, mode = "undirected")
cols <- vertcols[match(as.character(nodes[,1]),categories)]
lcols <- labcols[match(as.character(nodes[,1]),categories)]
set.seed(5)
plot(net, vertex.color = cols, vertex.size = vertsizes,
vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold,
main = "Randomized treatment: Fraudulent registration at control centers")
box(which = "plot", col = "black")
#
## Plot 3: Spilled over treatment
#
# Assigning treatment/control to nodes as an attribute
nodes <- as.data.frame(c("C","T","C","C","C","T","C","C","T","T"))
# Defining some reference vectors for plotting
vertcols <- c("#56B4E9", "#E69F00")
labcols <- c("black", "black")
categories <- c("T", "C")
vertsizes <- rep(25, nrow(adj.mat))
vertsizes[nodes == "T"] <- 15
# Plotting
net <- graph.adjacency(adj.mat, mode = "undirected")
cols <- vertcols[match(as.character(nodes[,1]),categories)]
lcols <- labcols[match(as.character(nodes[,1]),categories)]
set.seed(5)
plot(net, vertex.color = cols, vertex.size = vertsizes,
vertex.label = as.character(nodes[,1]),
vertex.label.color = lcols, vertex.label.cex = .85,
edge.color = "black",
layout=layout.fruchterman.reingold,
main = "Interference: Fraudulent registration has spread")
box(which = "plot", col = "black")
all_parameters <- NULL
copartisan_cohort_binary_results <- NULL
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary1.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
setwd("~/git/interference_field_experiments/Analysis/Bergan_replication")
all_parameters <- NULL
copartisan_cohort_binary_results <- NULL
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary1.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary2.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary3.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary4.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary5.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary6.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary7.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary8.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary9.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary10.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary11.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary12.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary13.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary14.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary15.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_copartisan_cohort_chamber_binary16.RData")
copartisan_cohort_binary_results <- c(copartisan_cohort_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
parameters <- all_parameters
BFP.results.summary <- function(parameters,p.values,level=0.95){
threshold <- 1-level
estimate <- as.numeric(parameters[which.max(p.values),])
CIs <- NULL
for(p in 1:ncol(parameters)){
select.col <- 0
for(c in (1:ncol(parameters))[-p]){
select.col <- select.col + 1*(parameters[,c]==estimate[c])
}
select.col <- which(select.col==(ncol(parameters)-1))
parameters.p <- parameters[select.col,p]
p.values.p <- p.values[select.col]
parameters.p <- parameters.p[which(p.values.p>threshold)]
CIs <- rbind(CIs,c(min(parameters.p),max(parameters.p)))
}
list(estimate,CIs)
}
summary.copartisan_cohort_binary <- BFP.results.summary(parameters,copartisan_cohort_binary_results)
summary.copartisan_cohort_binary.9 <- BFP.results.summary(parameters,copartisan_cohort_binary_results,level=0.9)
library(xtable)
cohort.table <- cbind(summary.copartisan_cohort_binary[[1]],summary.copartisan_cohort_binary[[2]],summary.copartisan_cohort_binary.9[[2]])
xtable(cohort.table)
rm(list=ls())
all_parameters <- NULL
cospon_binary_results <- NULL
load("BerganSPPQRRresults_cospon_binary1.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary2.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary3.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary4.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary5.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary6.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary7.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary8.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary9.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary10.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary11.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary12.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary13.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary14.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary15.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
load("BerganSPPQRRresults_cospon_binary16.RData")
cospon_binary_results <- c(cospon_binary_results,do.call('rbind',BFP.results)[,1])
all_parameters <- rbind(all_parameters,parameters)
parameters <- all_parameters
View(head(parameters))
BFP.results.summary <- function(parameters,p.values,level=0.95){
threshold <- 1-level
estimate <- as.numeric(parameters[which.max(p.values),])
CIs <- NULL
for(p in 1:ncol(parameters)){
select.col <- 0
for(c in (1:ncol(parameters))[-p]){
select.col <- select.col + 1*(parameters[,c]==estimate[c])
}
select.col <- which(select.col==(ncol(parameters)-1))
parameters.p <- parameters[select.col,p]
p.values.p <- p.values[select.col]
parameters.p <- parameters.p[which(p.values.p>threshold)]
CIs <- rbind(CIs,c(min(parameters.p),max(parameters.p)))
}
list(estimate,CIs)
}
summary.cospon_binary <- BFP.results.summary(parameters,cospon_binary_results)
summary.cospon_binary.9 <- BFP.results.summary(parameters,cospon_binary_results,level=0.9)
library(xtable)
cospon.table <- cbind(summary.cospon_binary[[1]],summary.cospon_binary[[2]],summary.cospon_binary.9[[2]])
xtable(cospon.table)
